using System;
using System.Net.Sockets;
using System.Text;
using System.Security.Cryptography;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Threading;
using System.Collections.Generic;
using System.Net;

namespace PayloadDownloader
{
    class Program
    {
        static void Main(string[] args)
        {
            var hashes = PopulateHashes();

            while (true)
            {
                byte[] payload;
                payload = get_payload();
                if (payload != null)
                {
                    string sha256hash = ComputeSha256Hash(payload);
                    if (!hashes.Contains(sha256hash))
                    {
                        Console.WriteLine("New binary!");
                        Console.WriteLine("SHA-256: " + sha256hash);
                        //PostToElastic(sha256hash);
                        string path = ".\\bin\\" + sha256hash + ".bin";
                        try
                        {
                            File.WriteAllBytes(path, payload);
                            Console.WriteLine("Saved to " + path);
                            hashes.Add(sha256hash);
                        }
                        catch
                        {
                            Console.WriteLine("Couldn't write file to disk!");
                        }
                    }
                    else
                    {
                        Console.WriteLine("No new binary this time");
                    }
                }
                else
                {
                    Console.WriteLine("Null received");
                }
                Thread.Sleep(300000);
            }
        }

        static byte[] get_payload()
        {
            byte[] decryption_key_byte_array = send_command("getPassword");
            if (decryption_key_byte_array != null)
            {
                try
                {
                    string decryption_key = Encoding.UTF8.GetString(decryption_key_byte_array);
                    string decryption_key_mod = decryption_key.Replace("a", "b").Replace("M", "C").Replace("1", "9").Replace("0", "a100");
                    byte[] payload = send_command("getAssembly");
                    byte[] decrypted_payload = binary_decryption(decryption_key_mod, payload);
                    byte[] unzipped_payload = unzip_payload(decrypted_payload);
                    return unzipped_payload;
                }
                catch
                {
                    return null;
                }
            }
            else
            {
                return null;
            }
        }

        static byte[] send_command(string command)
        {
            byte[] result = null;
            Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            try
            {
                socket.Connect("149.202.10.237", 5454);
                byte[] array = Encoding.UTF8.GetBytes(command);
                byte[] array_lenght = BitConverter.GetBytes(array.Length);
                socket.Send(array_lenght, 0, array_lenght.Length, SocketFlags.None); //send data lenght
                socket.Send(array, 0, array.Length, SocketFlags.None); //send command
                byte[] data_lenght = new byte[4];
                Program.Receive(socket, data_lenght, 0, data_lenght.Length, 10000);
                byte[] data = new byte[BitConverter.ToInt32(data_lenght, 0)];
                Program.Receive(socket, data, 0, data.Length, 10000);
                result = data;
                socket.Shutdown(SocketShutdown.Both);
                socket.Close();
                return result;
            }
            catch {
                return result;
            }
        }

        static byte[] binary_decryption(string key, byte[] encrypted_binary)
        {
            byte[] result;
            byte[] salt = Encoding.UTF8.GetBytes("Ivan Medvedev");
            using (Aes aes = Aes.Create())
            {
                Rfc2898DeriveBytes deriveBytes_ = new Rfc2898DeriveBytes(key, salt);
                aes.Key = deriveBytes_.GetBytes(32);
                aes.IV = deriveBytes_.GetBytes(16);
                using (MemoryStream memoryStream = new MemoryStream())
                {
                    using (CryptoStream cryptoStream = new CryptoStream(memoryStream, aes.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        cryptoStream.Write(encrypted_binary, 0, encrypted_binary.Length);
                        cryptoStream.Close();
                    }
                    result = memoryStream.ToArray();
                }
            }
            return result;
        }
        static byte[] unzip_payload(byte[] payload)
        {
            GZipStream gzipStream = new GZipStream(new MemoryStream(payload), CompressionMode.Decompress);
            byte[] result;
            MemoryStream memoryStream = new MemoryStream();
            using (memoryStream)
            {
                gzipStream.CopyTo(memoryStream);
                result = memoryStream.ToArray();
            }
            return result;
        }

        public static void Receive(Socket socket, byte[] buffer, int offset, int size, int timeout)
        {
            int startTickCount = Environment.TickCount;
            int received = 0;  // how many bytes is already received
            do
            {
                if (Environment.TickCount > startTickCount + timeout)
                    throw new Exception("Timeout.");
                try
                {
                    received += socket.Receive(buffer, offset + received, size - received, SocketFlags.None);
                }
                catch (SocketException ex)
                {
                    if (ex.SocketErrorCode == SocketError.WouldBlock ||
                        ex.SocketErrorCode == SocketError.IOPending ||
                        ex.SocketErrorCode == SocketError.NoBufferSpaceAvailable)
                    {
                        // socket buffer is probably empty, wait and try again
                        Thread.Sleep(30);
                    }
                    else
                        throw ex;  // any serious error occurr
                }
            } while (received < size);
        }

        static string ComputeSha256Hash(byte[] rawData)
        {
            // Create a SHA256   
            using (SHA256 sha256Hash = SHA256.Create())
            {
                // ComputeHash - returns byte array  
                byte[] bytes = sha256Hash.ComputeHash(rawData);

                // Convert byte array to a string   
                StringBuilder builder = new StringBuilder();
                for (int i = 0; i < bytes.Length; i++)
                {
                    builder.Append(bytes[i].ToString("x2"));
                }
                return builder.ToString();
            }
        }

        static void PostToElastic(string sha256)
        {
            //string url = "http://10.0.0.6:9200";
            string url = "http://192.168.56.104:9200";
            string path = "/binary/_doc/";
            string pipeline = "?pipeline=timestamp";
            var httpWebRequest = (HttpWebRequest)WebRequest.Create(url + path + pipeline);
            httpWebRequest.ContentType = "application/json";
            httpWebRequest.Method = "POST";
            using (var streamWriter = new StreamWriter(httpWebRequest.GetRequestStream()))
            {
                string json = "{\"SHA-256\":\"" + sha256 + "\"}";
                streamWriter.Write(json);
            }
            var httpResponse = (HttpWebResponse)httpWebRequest.GetResponse();
            using (var streamReader = new StreamReader(httpResponse.GetResponseStream()))
            {
                var result = streamReader.ReadToEnd();
            }
        }

        static List<string> PopulateHashes()
        {
            string[] files = Directory.GetFiles(@".\\bin\", "*.bin");
            var hashes = new List<string>();

            foreach (string s in files)
            {
                int pFrom = s.LastIndexOf("\\") + 1;
                int pTo = s.LastIndexOf(".");
                hashes.Add(s.Substring(pFrom, pTo - pFrom));
            }

            return hashes;
        }
    }
}